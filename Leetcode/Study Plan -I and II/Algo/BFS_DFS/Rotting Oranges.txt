You are given an m x n grid where each cell can have one of three values:

0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

 

Example 1:
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4

Example 2:
Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.

Example 3:
Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.

Solution:

class Solution {
    public int orangesRotting(int[][] grid) {
        
        Set<String> fresh = new HashSet<>();
        Set<String> rotten = new HashSet<>();
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[i].length;j++){
                if(grid[i][j] == 1){
                    
                    fresh.add(""+i+j);
                } 
                if(grid[i][j] == 2){
                    
                  rotten.add(""+i+j);  
                } 
            }
        }
        int minutes = 0;
        int [][] directions={{0,1}, {1,0}, {-1,0}, {0,-1}};
        while(fresh.size() >0){
            Set<String> infected = new HashSet<>();
            for(String s:rotten){
                int i = s.charAt(0) - '0';
                int j = s.charAt(1) - '0';
                for(int[] direction: directions){
                    int nextI = i+ direction[0];
                    int nextJ = j+ direction[1];
                    if(fresh.contains(""+nextI+nextJ)){
                        fresh.remove(""+nextI+nextJ);
                        infected.add(""+nextI+nextJ);
                    }
                } 
                
            }
            //System.out.println(infected.size());
            if(infected.size() == 0) return -1;
            
            rotten = infected;
            minutes++;
        }
        return minutes;
        
    }
} 


---------------------------------------------------

Optimal approach:

class Solution {
    public int orangesRotting(int[][] grid) {
      int i,j,n=grid.length,m=grid[0].length,ans=0,frsh=0;
        Queue<int[]> queue=new LinkedList();
        
        for(i=0;i<n;i++)
            for(j=0;j<m;j++) {
                if(grid[i][j]==2) {

                    queue.add(new int[]{i,j});  grid[i][j]=0;
                }
                else if(grid[i][j]==1)
                    frsh++;
			}
        
        while(!queue.isEmpty())  {
            
            int size=queue.size();
            while(size-->0)
            {
                int tm[]=queue.poll();
                i=tm[0];
                j=tm[1];
                if(i+1<n&&grid[i+1][j]==1) {
                    
                    queue.add(new int[]{i+1,j});  grid[i+1][j]=0; frsh--;
                }
                if(j+1<m&&grid[i][j+1]==1) {
                    
                    queue.add(new int[]{i,j+1});  grid[i][j+1]=0; frsh--;
                }
                if(i-1>=0&&grid[i-1][j]==1) {
                    
                    queue.add(new int[]{i-1,j});  grid[i-1][j]=0;  frsh--;
                }
                if(j-1>=0&&grid[i][j-1]==1) {
                    
                    queue.add(new int[]{i,j-1});  grid[i][j-1]=0;  frsh--;
                }
            }
            if(queue.size()>0)
                ans++; 
        }
        
        if(frsh>0)
            return -1;
        return ans;
        
    }
}